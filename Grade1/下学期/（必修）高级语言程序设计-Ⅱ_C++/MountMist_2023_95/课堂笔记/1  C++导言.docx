命名空间（namespace）:
某一个所有指令集与命名集的总和，故而各个工作小组定义的同名函数或变量不会互相影响
系统存在预定义的自带命名空间std
这就是写了多年但不知道含义的using namespace std;

预编译命令（#）
文件包含命令 #include<bits/stdc++.h>   //已经预置的头文件使用尖括号<>
		  #include"头文件"		    //自己编写的其他文件也加入此代码中进行编译使用双引号“”

函数的调用为其分配栈空间
先为自定义函数分配空间，

函数原型声明
以下等价：
void swap( int *p1, int *p2);
void swap( int *, int *);


------C++相比C而言“++”在了哪里？--------
作用域限定符：全局变量表达为“::i” 局部变量表达为“i”
常量标识符const  ：在定义时必须赋初值 且const 的变量无法进行改变，改变常量的行为会在编译时报错；
内联函数：“inline”内联函数不会另外分配栈空间，在运行时直接代入实参，相当于是把内联			函数内部的代码直接填入调用位置
			这样做就节省了另外调用函数所需要的时间与空间
			但是在inline函数内容过于复杂时，这样做会导致代码的冗余
函数重载：可以将同一名字的函数或标识符由我重新定义
		且函数重载可以允许不同的函数具有相同的名字，
　　		在名字相同时通过参数表来互相区分，
		但是参数表相同，返回值类型不同的函数认为是非法的，
　　　因为调用时候编译器无法正确匹配对应的函数
　　　如：float Function( float , float )与void Function( float , float );是非法的


默认参数：函数的形参可以先为其赋予初值作为默认参数，这样可以避免用户如果疏忽而未传入参数而导致的编译错误，如果给出参数则以用户参数为准
		ex:  int f(int a=0, int b=1)

默认参数的构造可能出现二义性
如：
class X
{ 
public:
         X( );
         X( int i=0 ,int y=0);
};
void main ( ) 
{
     X a(10,10);
      X b;     
}
此程序具有歧义，无法正确匹配

引用：只有当取址符& 之前有数据类型时，此时&表示引用
	引用变量与原变量等价，对引用变量和原变量的改变均会对此变量造成影响
	ex:  int i=1;  int &j=i;  
		i++; j++;
	（-->结果为i=3; j=3)
内存管理new与delete：
	malloc（）函数申请堆内存在C++中表达为new
	delete（）函数释放堆内存表达为free

