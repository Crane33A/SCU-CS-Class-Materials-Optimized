变量记得初始化
变量记得初始化
变量记得初始化
啊啊啊啊啊啊啊啊啊啊啊啊

计算机内以最高位表示正和负
ascll码中存在无法识别符号如空格，但可以通过一定的符号来表示，在char中起作用
单个char中只能存储一个字符，否则需要用数组

’\0’是判定字符数组结束的标识，表示这串字符到结尾了；
在字符数组中’\0’是占一个位置的！
例如 定义char c[6]=“hello”，而在内存中字符数组 c 则是"hello\0"；
即’\0’在数组中占有空间却不被我们看到；

转义字符    		意义       					   ASCII码值（十进制）
\a           		响铃(BEL)  						007
\b          		退格(BS) ，将当前位置移到前一列    		008
\f           		换页(FF)，将当前位置移到下页开头    		012
\n          		换行(LF) ，将当前位置移到下一行开头    	010
\r           		回车(CR) ，将当前位置移到本行开头    		013
\t          		水平制表(HT) （跳到下一个TAB位置）    	009
\v          		垂直制表(VT)    					011
\\          		代表一个反斜线字符''\'    				092
\'          		代表一个单引号（撇号）字符    			039
\"         		代表一个双引号字符    				034

\0        		空字符(NULL)    					000

\ddd    		1到3位八进制数所代表的任意字符    		三位八进制
\xhh    		1到2位十六进制所代表的任意字符    		二位十六进制

char 				8bit
(unsigned) short (int) 	16bit 
long (int) 			32bit 
long long (int) 		64bit
不存在short float 

浮点数标准ulp

用0x来表示16进制数
每一位用四位二进制来表示
0x之后的数字写作16进制
example：   0x7 F
	       =0111 1111
	       =127

GitHub（国际版）
Gitee（国内版）

限制小数位数setprecision()<<fixed
限制字符占位setw()

指针：对地址进行编程  (*p)

*p是地址处于p处的变量的值
p也是p的变量的值
&p是p处地址的值
只要*p指向p则二者等价，对*p的改变也会改变p
如果函数以指针为参数，则自定义函数中对指针的改变是永久的，即会改变实参的值
（但是函数以形参为参数时，函数的传值只是实参值的copy，而不会改变实参的值）
指针的好处在于用指针作为函数的形参时，既可以读取也可以改变实参的值
指针也可作为赋值，但p=q和*p=*q完全不等价，前者表示两个指针指向同一个位置，后者表示把q指针的对象赋值给p指针的对象
指针在数组中可以进行运算（整数加减与指针相减），可表示数组下标的移动
可以直接用数组名对指针进行命名，*（a+1）与a[1]等价
字符串指针是例外
当一个指针*p直接指向某字符串“abcd”时，p与*p都直接代表该字符串的值

在C语言中字符串当作数组来处理
用=对字符串赋值是非法的（char a[10]；a="abc";//wrong）
但用=对字符数组初始化是合法的（char a[10]="abc";//correct）

用指向字符串的指针作为数组的元素，可以实现不定长字符串数组的定义char *a[]，其中的每一个元素都是指向以空字符结尾的字符串的指针；
而对其的访问与二维数组相同。例如，“ if(a[i][0]=='M') "是合法的

在定义函数时，在类型后加*可定义一个返回值为指针类型的函数
在定义指针时，若指针与某变量的名字相同，而作者想把此指针指向此变量的地址，则会出现错误
如 int x=1;  int *x=&x;则会出现错误

“. . .”可变参数列表
具有可变参数列表的函数就是：
函数定义时，参数列表中的的参数不完全定义；
调用该函数时，可以根据实际情况传入多个参数，且可以成功完成其函数功能。
而该函数的参数列表就是可变参数列表。

计算机读入字符时会在最后读入一个空字符‘/0’
或许可以用来检测输入是否结束
为了统一格式以便输入或采集数据
可将奇奇怪怪的字符转换掉，同时也可以避免输入中空格的干扰（例如把比分中的“：”和“-”都转换为‘ ’）、

c语言的字符串比较不可以直接用==，而是用strcmp()
