程序的储存空间分为栈空间、堆空间与静态空间（static）等
栈空间很小，堆空间比较大
全局变量以及静态变量（static int）分配堆空间
局部变量分配栈空间（栈空间一般上限在500000五十万左右）
所以当数组很大时候，放置于函数内部作为局部变量可能崩盘
而作为static 或全局变量则可行
				——luoguP1161开灯

getline函数可以直接读入一行数据，包括空格，只以回车为结束
用法：getline(cin,s) 其中s表示存储读入数据的字符串等数据结构
但注意由于是getline，无法控制从1开始，所以计数记得从0开始。
//事实上，字符串大多只能从0开始计数
				——luoguP5015标题统计

 strcat() 函数用来将两个字符串连接（拼接）起来
用法：strcat(str1,str2)表示将2连接到1的末尾
注意：str1末尾的\0会被覆盖，str2末尾的\0会一起被复制过去，最终的字符串只有一个\0。
可以用于简化配对过程
				——luoguP1308统计单词

埃氏筛：
思想：从2开始，每个素数的倍数不是素数。开一个bool数组，大小为范围内最大数。
先把数组内所有数置为“（假装）是素数（true）”
再把0和1置为FALSE，以免后续出错
从2开始筛，每当i是素数，便从2i开始（因为i是素数），把i的倍数（j+=i）置为“不是素数”（FALSE）
最后数组序号i便表示数字i，内容值便表示是否为素数
时间复杂度O(n log(log n) )
//在用埃式筛法的同时，同一个数字也许会被筛选多次，比如6先被2筛选一次，再被3筛选一次，这样也会浪费了很多不必要的时间
				——luoguP5736质数筛

欧拉筛（线性筛）：
思想 ：在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。
欧拉筛法通过if(i%prime[j]==0)break;这一步就避免了重复筛选的发生

有时或许无需多此一举，写的多错的可能多
if(cnt[i]>maxi){
		maxi=cnt[i];
		mini=i;	
		}即可
若增加判断，可能导致后续更大但频率更多的和无法被更新
				——luoguP2911Bovine Bones G

#include <cctype>
这是一个拥有许多字符串处理函数声明的头文件，这些函数可以用来对单独字符串进行分类和转换；
例如：
函数名称	返回值
isalnum()	如果参数是字母数字，即字母或数字，该函数返回true

isalpha()	如果参数是字母，该函数返回真

isblank()	如果参数是空格或水平制表符，该函数返回true
iscntrl()	如果参数是控制字符，该函数返回true

isdigit()	如果参数是数字（0～9），该函数返回true

isgraph()	如果参数是除空格之外的打印字符，该函数返回true
islower()	如果参数是小写字母，该函数返回true
isprint()	如果参数是打印字符（包括空格），该函数返回true
ispunct()	如果参数是标点符号，该函数返回true
isspace()	如果参数是标准空白字符，如空格、进纸、换行符、回车、水平制表符或者垂直制表符，该函数返回true
isupper()	如果参数是大写字母，该函数返回true
isxdigit()	如果参数是十六进制的数字，即0～9、a~f、A~F，该函数返回true
tolower()	如果参数是大写字符，则返回其小写，否则返回该参数
toupper()	如果参数是小写字母，则返回其大写，否则返回该参数

atoi ((表示 ascii to integer)是把字符串转换成整型数的一个函数)
直接将输入的字符串转成整数
例如 x=atoi(ss);

sprintf()是一个将数据输入有格式字符串的函数，可以把数值按某种格式输出
sprintf(ans, "%d*%d=%d", x , y , x*y);
（相当于是为字符串赋值）
					——luoguP1957 口算练习题
同理，也存在sscanf()，可以从有格式的字符串中提取数值
sscanf(match, "%s %s %d %d",t1,t2,&s1,&s2)

当连续输入（无空格，有或没有换行）但需要逐个处理时，for的死循环结合getchar较为合适
for(int i=1;;i++)
	{
		a=getchar();
		if(a!='W'&&a!='L')batt[i]=3;
		if(a=='W')batt[i]=1;
		if(a=='L')batt[i]=2;
		if(a=='E')break;
	}
通过break退出循环，此方法可以不需要确定输入的个数
同时，将字符转化为数字数组来表示可以易于存储与多次处理
					——luoguP1042	[NOIP2003 普及组] 乒乓球

当使用几个数字而非和来记录某状态时，注意此数字是否会在循环中累计。
如果会累计，则应该在循环开始时取模，否则会打乱之后的进程；
或者直接将次态写成赋值而非自增；
if(tc==1&&gc){
			if(a[xc-1][yc]=='*'||xc==1){

			///****tc=2****/// 		;gc=false;

			}
			else {
				xc--;gc=false;
			}
		}
还要注意的是自加的取值，有时不需要画蛇添足，多判断一次可能会导致少自加一次。
				——luoguP1518	[USACO2.4]两只塔姆沃斯牛 The Tamworth Two

在 STL 里有一个神奇的函数 nth_element。
它的用法是 nth_element(a+x,a+x+y,a+x+len);。
执行之后数组 a 下标 x 到 x+y-1x+y−1 的元素都小于 a[x+y]a[x+y]，
下标 x+y+1x+y+1 到 x+len-1x+len−1 的元素 都大于 a[x+y]a[x+y]，但不保证数组有序。
此时 a[x+y]a[x+y] 就是数组区间 x 到 x+len-1x+len−1 中第 y 小的数，当然也可以自己定义 cmp 函数。
nth_element 的时间复杂度是 O(n)的，虽然 STL 常数普遍较大，但还是能过一般的题。
				——luoguP1923 【深基9.例4】求第 k 小的数

C++STL里面的函数：next_permutation制造下一个全排列
利用这个函数，制造一个新的数组从{1,2,……n}开始到{a1,a2,……an}
用法为next_permutation(b,b+n);需要先给b数组赋值，然后能直接使得b数组变为下一个全排列
注意此函数不会产生b数组本身，而是直接从b数组的下一个全排列开始
但是通过一些操作仍然可以使用此函数来完成全排列输出
				——luoguP2524 Uim的情人节礼物·其之弐

使用桶排时尤其需要考虑数组越界问题，如果数据过大而数组不够大就会导致出错
“但是这份代码只能得60分，原因是他会出现差大于1000的情况，导致数组越界。而解决方案就是把数组开大点。”
有时候一味地把数组开大也不能解决问题，从原理上优化才是更好的方法
“但是，这只是因为数据太弱。那么观察发现每种情况只能且必须出现一次，所以只要出现重复或者超出界限，就输出"Not jolly"。”
				——luoguP1152欢乐的跳

